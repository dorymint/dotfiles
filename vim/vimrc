"
" vimrc
"
"-----| fileencoding |-----"
set encoding=utf-8
scriptencoding utf-8

" TODO: 時間が取れたら整理する
" コメント多めに書く
" fix path for windows

" NOTE: 設定の詳細は:helpで調べればまず困らない
" 日本語のヘルプは https://github.com/vim-jp/vimdoc-ja
" NORMALモードで : を押すとコマンドを入力するモードに移る
" setの詳細は :help ${name} もしくは :help set で確認
" setはできるだけ省略せずに書く set nohl --> set nohlsearch
" Vim script は最初の非空白文字を \ にすることで前の行と連結できる
" vim の echo は内部変数を除くのにべんり :echo &encoding
" 関数の結果を見るにもべんり :echo expand("%:p")
" :help echo

" NOTE: true and false
" those variable is read only
" v:true = 1
" v:false = 0
" :echo v:true != v:false
" :echo v:true == v:false

" 以下のヘルプを見ておけば迷わないと思う
" base
" :help help
" :help helplang
" :help search-commands
" :help set-option
" :help option-summary
" mapping
" :help index
" :help motion
" :help operator
" function
" :help function
" :help functions
" :help function-list
" :help expand
" variable
" :help internal-variables
" :help v:
" :help v:true
" :help v:false
" :help g:
" :help s:
" extra
" :help runtimepath
" :help scriptnames
" :help object-motions
" :help registers


"-----| plugin manage |-----"
if (has('win32') || has('win64')) && isdirectory(glob('~/.vim'))
	" NOTE: linuxに合わせる
	set runtimepath^=~/.vim,~/.vim/after
endif

if v:true
	" plug
	if filereadable(glob('~/.vim/autoload/plug.vim'))
		source ~/dotfiles/vim/plugin-manage-plug.vim
	else
		echo 'not found: autoload/plug.vim'
	endif
else
	" minpac
	if filereadable(glob('~/dotfiles/vim/minpac-pkg.vim'))
		source ~/dotfiles/vim/minpac-pkg.vim
	endif
endif


"-----| set |-----"
	set ttyfast
	set notimeout
	"set timeoutlen=1000
	set ttimeout
	set ttimeoutlen=100
	set modeline

	" NOTE: modelines ファイル頭と尻尾のコメントを書くとき注意する
	" {vi:|vim:|Vim:|ex:}でぶつかる
	set modelines=5

	set hidden
	set autoread

	" NOTE: 貼り付けで形が崩れる場合は :paste して貼付け後に :nopaste する
	" keymapでトグル指定
	set nopaste


	set backspace=indent,eol,start
	set completeopt=menuone,preview
	set display=truncate
	set nrformats=bin,octal,hex
	set helplang=ja,en
	set nospell

	" NOTE: cjk を追加で東アジア圏の言葉をチェックから除外できるらしい
	set spelllang=en,cjk

	set title
	set ruler
	set number
	set norelativenumber
	set scrolloff=5
	set textwidth=0
	set wrap

	" NOTE: 折り返しのインデントを合わせる,vim8
	set breakindent

	" NOTE: :help revins :)
	set norevins

" cursor
	set nocursorcolumn
	set nocursorline

" foldmethod
	set foldmethod=marker
	set foldmarker={{{,}}}
	set foldlevel=0

	" NOTE: デフォルトは開くように
	" :help zi
	set nofoldenable
	function! Giko()
		return ' (,,ﾟДﾟ)' . foldtext()
	endfunction
	set foldtext=Giko()

" showmatch
	set showmatch
	set matchtime=1
	set matchpairs=(:),{:},[:],<:>

" cmdline
	set showcmd
	set history=1000
	set cmdheight=1
	set wildmenu
	set wildmode=list:longest,full
	set confirm

	" NOTE: vimから呼ぶシェルを設定, shell=zsh
	"set shell=bash

" search
	set incsearch

	" NOTE: keymapでトグル指定
	set hlsearch

	" NOTE: 置換処理のマッチにも影響するため注意
	" ignorecase 大文字少文字を区別しない
	" smartcase 検索条件に大文字が含まれると noignorecase
	set ignorecase
	set smartcase

" indent
	set autoindent
	set smartindent
	set shiftwidth=2
	set smarttab

" tab
	set noexpandtab
	set tabstop=2
	set softtabstop=2

" list
	set list

	" NOTE: eolは考慮中 eol:↵
	set listchars=tab:>-,trail:-,nbsp:%,extends:>,precedes:<

" statusline
	set laststatus=2

	" NOTE: %[n]?[.] の形式で指定してる、詳細は:help statuslineで確認
	" 設定はプラグインが効かないときだけ
	set statusline=%f%m%r%w%y%{&fileencoding}[%{&fileformat}]%=%(buf[%n]hex[%4B]line[%4l/%4L:%4P]%)

" tabline
	set showtabline=1

	" NOTE: 設定はstatuslineと似てる :help tabline
	"set tabline=

" split
	set splitbelow
	set splitright

" visualbell
	" NOTE: set visualbell でbeep音を画面のフラッシュと置き換える
	" t_vb= でフラッシュのターミナルコードを空指定してフラッシュさせない
	set visualbell
	set t_vb=

" backup, swap, undo
	set nobackup
	set writebackup
	set noundofile
	set noswapfile

" tmp directory
if isdirectory(glob('~/dotfiles/vim/tmp'))
	set backupdir=~/dotfiles/vim/tmp/backup
	set undodir=~/dotfiles/vim/tmp/undo
	set directory=~/dotfiles/vim/tmp/swap
	set backup
	set undofile
	set swapfile
else
	echo 'not found ~/dotfiles/vim/tmp'
endif


"-----| color |-----"
" NOTE: シェルの設定で変わるのでlocalで設定するか分岐を作った方がいいかも

" colorscheme
if $TERM == "xterm-256color" ||
			\ $TERM == "xterm-termite" ||
			\ $TERM == "screen-256color" ||
			\ $TERM == "rxvt-unicode-256color"
	set t_Co=256
	try
		"set background=dark
		colorscheme jellybeans
		"colorscheme hybrid
		"colorscheme iceberg
		"colorscheme molokai
	catch
	endtry
else
	try
		"set background=dark
		colorscheme elflord
	catch
	endtry
endif

" set has win
if has('win32') || has('win64')
	set t_Co=16
endif

syntax on


"-----| key map |-----"
" NOTE: (,,ﾟДﾟ)つ:help index
" defaultのマップは :help index で確認できる
" user定義のマップは :imap :nmap :vmap :map :verbose map で確認できる
" なるべくデフォルトを消さないようにマップする
" <C-s>はttyへの入力受付をロックする?<C-q>で復帰、端末制御に使うキーはマップに注意する
" <C-b>はtmuxと被る、tmuxを変えずにvimでマップしないようにしてみる
" <C-z>はサスペンド、jobsでサスペンドの確認、fgでフォアグラウンド
" <Nop>はマップを削除できる
" コマンドのキーマップは<C-u>で数値の前置を消しておかないと範囲指定される
" mapleaderが有用
" :help <Leader>

" mapleader
if v:true
	" TODO: consider
	let g:mapleader = "\<Space>"
	let g:maplocalleader = "\\"
endif


" NORMAL map
	" NOTE: disable all erase?
	"nnoremap zE <Nop>

	" Resize window
	nnoremap <Up> <Nop>
	nnoremap <Down> <Nop>
	nnoremap <Left> <Nop>
	nnoremap <Right> <Nop>
	" NOTE: <Nop> で消しておくとリサイズの処理が軽くなる?
	nnoremap <Up> <C-w>+
	nnoremap <Down> <C-w>-
	nnoremap <Left> <C-w><
	nnoremap <Right> <C-w>>

	" 行を上下に引っ張る
	" NOTE: <C-k>はファイルの先頭で入れると行が消える、挙動の理由がよくわかってない
	" ddまでは動いて、kが失敗すると止まるっぽい? dd && k && P
	"nnoremap <C-j> ddp
	"nnoremap <C-k> ddkP
	" NOTE: reg を汚さない . は現在行、こちらなら行は消えない
	nnoremap <C-j> :<C-u>. move +1<CR>
	nnoremap <C-k> :<C-u>. move -2<CR>

	" 改行の挿入
	" NOTE: このマップはもう少し考えたい
	nnoremap <CR> o<Esc>

	" prefix <Leader>
	" NOTE: reserved prefixes
	" <Leader>T
	" <Leader>set
	" <Leader>c
	" <Leader>xxd
	" <Leader>rxxd

		" buffer
		nnoremap <Leader>j :<C-u>bnext<CR>
		nnoremap <Leader>k :<C-u>bprev<CR>
		nnoremap <Leader>ls :<C-u>ls<CR>
		nnoremap <Leader>bl :<C-u>ls<CR>:buffer<Space>
		nnoremap <Leader>bs :<C-u>ls<CR>:sbuffer<Space>
		nnoremap <Leader>bd :<C-u>ls<CR>:bdelete<Space>
		nnoremap <Leader>bk :<C-u>bdelete<CR>
		nnoremap <Leader>bn :<C-u>enew<CR>

		" tabpage
		nnoremap <Leader>n :<C-u>tabnext<CR>
		nnoremap <Leader>p :<C-u>tabprevious<CR>
		nnoremap <Leader>N :<C-u>tabnew<CR>
		nnoremap <Leader>C :<C-u>tabclose<CR>
		" TODO: consider to remove
		nnoremap <Leader>mn :<C-u>+tabmove<CR>
		nnoremap <Leader>mp :<C-u>-tabmove<CR>

		" mark
		nnoremap <Leader>mm :<C-u>marks<CR>

		" register
		" NOTE: help: registers
		nnoremap <Leader>reg :<C-u>registers<CR>

		" NOTE: autocmd Filetype で設定したほうがよさそう
		" :help object-motions
		" search and move
		nnoremap <Leader>; /}<CR>
		nnoremap <Leader>> /><CR>

		" NOTE: match over 80 characters
		" :help pattern
		nnoremap <Leader>ol /\%80v.\+<CR>

	" toggle: <Leader>T
		nnoremap <Leader>Th :<C-u>set hlsearch!<CR>
		nnoremap <Leader>Tl :<C-u>set list!<CR>
		nnoremap <Leader>Tc :<C-u>set cursorcolumn! cursorline!<CR>
		nnoremap <Leader>Tn :<C-u>set number!<CR>
		nnoremap <Leader>Te :<C-u>setlocal expandtab!<CR>
		nnoremap <Leader>Ts :<C-u>setlocal spell!<CR>
		nnoremap <Leader>Tp :<C-u>setlocal paste!<CR>
		nnoremap <Leader>Tr :<C-u>setlocal readonly!

	" set: <Leader>set
		nnoremap <Leader>setft :<C-u>setlocal filetype=
		nnoremap <Leader>settw :<C-u>setlocal textwidth=0
		nnoremap <Leader>setenc :<C-u>e ++enc=shift_jis

	" quickfix: <Leader>c
		nnoremap <Leader>cn :<C-u>cnext<CR>
		nnoremap <Leader>cp :<C-u>cprevious<CR>
		nnoremap <Leader>co :<C-u>copen<CR>
		nnoremap <Leader>cw :<C-u>cwindow<CR>
		nnoremap <Leader>cc :<C-u>cclose<CR>

		" hex
		if executable('xxd')
			" NOTE: 戻す時は xxd -r
			" T[rR]xxd みたいに書きたい
			" Trxxd conflict readonly!
			nnoremap <Leader>xxd :<C-u>setlocal filetype=xxd<CR>:%!xxd<Space>
			nnoremap <Leader>rxxd :<C-u>%!xxd -r<Space>
		else
			echo 'not found xxd'
		endif


" INSERT mode
	" NOTE: <C-[> に慣れた方がいいかも
	" ノーマルモードに
	"inoremap jj <Esc>
	"inoremap jk <Esc>
	"inoremap kj <Esc>

	" インサートモードの移動
	" TODO: もう少し考える...無くてもいいかも
	" NOTE: <C-b> tmux とかぶる
	" <C-f> 再インデントを上書き
	" <C-h> バックスペース
	inoremap <C-f> <Right>
	inoremap <C-b> <Left>
	" NOTE: emacs
	"inoremap <C-a> <Home>
	"inoremap <C-e> <End>
	"inoremap <C-b> <Left>
	"inoremap <C-a> <Right>
	"inoremap <C-p> <Up>
	"inoremap <C-n> <Down>

if v:false
	" 閉じ括弧
	inoremap {} {}<C-g>U<Left>
	inoremap () ()<C-g>U<Left>
	inoremap [] []<C-g>U<Left>
	inoremap <> <><C-g>U<Left>
	inoremap "" ""<C-g>U<Left>
	inoremap '' ''<C-g>U<Left>
endif
	inoremap {<enter> {}<Left><enter><Esc><S-o>
	inoremap {<CR> {}<Left><CR><Esc><S-o>
	inoremap (<enter> ()<Left><enter><Esc><S-o>
	inoremap (<CR> ()<Left><CR><Esc><S-o>
	inoremap [<enter> []<Left><enter><Esc><S-o>
	inoremap [<CR> []<Left><CR><Esc><S-o>
	" NOTE: <enter>と<CR>、違いがよくわかってない
	" 入力は別扱い、挿入が<eol>、書き込みがff依存?

	" オムニ補完
	inoremap <S-Tab> <C-x><C-o>

	" undo
	inoremap <C-u> <C-g>u<C-u>
	inoremap <C-w> <C-g>u<C-w>

	" 全角を半角に
	" NOTE: :help i_ctrl-v
	inoremap 　 <Space>
	inoremap （ (
	inoremap ） )
	inoremap ｛ {
	inoremap ｝ }
	inoremap ； ;
	inoremap ： :
	inoremap ｜ <Bar>
	inoremap ＜ <
	inoremap ＞ >
	inoremap ＊ *
	inoremap ＠ @
	inoremap ％ %
	inoremap ＃ #
	inoremap ’ '
	inoremap ＋ +
	inoremap ０ 0
	inoremap １ 1
	inoremap ２ 2
	inoremap ３ 3
	inoremap ４ 4
	inoremap ５ 5
	inoremap ６ 6
	inoremap ７ 7
	inoremap ８ 8
	inoremap ９ 9
	inoremap ？ ?
	inoremap ！ !
	"inoremap ー -
	"inoremap 〜 ~

" V-LINE mode
" TODO: consider to useful
	" TODO: to use :move or function
	snoremap <C-j> dp
	" NOTE: if use at top line then delete select lines
	snoremap <C-k> dkP


"-----| tool |-----"
" TODO: reconsider copen, to simple
" fix for os windows
let s:errlist = []
let s:sfile = expand('<sfile>')
let s:errnum = 1
function! s:adderr(msg, ...) abort
	call add(s:errlist, {
				\ 'nr': s:errnum ,
				\ 'type': 'W' ,
				\ 'filename': s:sfile ,
				\ 'pattern': a:0 == 0 ? a:msg : a:1 ,
				\ 'text': a:msg ,
				\ })
endfunction

if isdirectory(glob('~/dotfiles/vim/tmp'))
	" go-todogotcha
	if executable('gotcha')
		function! s:gotcha(...) abort
			split ~/dotfiles/vim/tmp/gotcha.log
			% delete _
			let l:word = a:0 == 0 ? "TODO: " : a:1
			let l:opt = '-word=' . l:word . ' ' .
						\ '-ignore-dirs=".git:.cache:tmp:backup" ' .
						\ '-sync ' .
						\ '-cache ' .
						\ '-verbose ' .
						\ '-total'
			let l:cmd = 'gotcha ' . l:opt
			put =system(l:cmd)
			write
		endfunction
		command! -nargs=? Gotcah call s:gotcha(<f-args>)
		" NOTE: List内のファイル名からgfで飛べる
	else
		call s:adderr('gotcha')
	endif

	" reps.bash
	if executable('reps.sh')
		function! s:repsStatus() abort
			split ~/dotfiles/vim/tmp/reps.log
			% delete _
			read !reps.sh status
			write
		endfunction
		command! Reps call s:repsStatus()
	else
		call s:adderr('reps.bash')
	endif
else
	call s:adderr('not found ~/dotfiles/vim/tmp/')
endif

	" xclip
	if executable('xclip')
		command! Paste read !xclip -o
		command! -range Cut <line1>,<line2>!xclip
	else
		call s:adderr('xclip')
	endif

	" timestamp
	if exists('*strftime')
		command! Timestamp :put =strftime('%Y/%m/%d')
	else
		call s:adderr('strftime')
	endif

if !empty(s:errlist)
	call setqflist(s:errlist, 'r', { 'nr': s:errnum, 'title': 'vimrc tool errlist'})
	call setqflist(s:errlist, 'a')
	echoerr 'tools activate error: count=' . len(s:errlist) . ' check to :copen'
	"copen
endif


"-----| autocmd |-----"
" NOTE: filetypeによる挙動の変化を有効に設定
" nyan_vimrc for reloadable vimrc
filetype plugin indent on
augroup nyan_vimrc
	" NOTE: nyan_vimrcグループのautocmdを初期化して再設定を防ぐ
	autocmd!

" vim
	" NOTE: (# ﾟДﾟ)つ textwidth がどこで set されたかわかんない!
	" おとなしく modeline 使った方が良さそう
	"autocmd Filetype vim setlocal textwidth=0

" golang
	" NOTE: goはハードタブが推奨される、noexpandtabとスペースの表示をfmtに合わせて設定
	autocmd Filetype go setlocal noexpandtab shiftwidth=4 tabstop=4 softtabstop=4
		" listchars-=tab したかったけど動かなかった
		" lictchars+=tab:\ \ , でもいいけどtabが重複する
		"listchars=tab:\ \ ,trail:-,nbsp:%,extends:>,precedes:<,

	" NOTE: QuickRunを使うなら以下は無効
	"if isdirectory(glob('~/dotfiles/vim/tmp'))
		"autocmd Filetype go nnoremap <buffer> <c-@>gorun :<C-u>!go run % > ~/dotfiles/vim/tmp/gorunlog.txt 2>&1<CR>
	"endif

" python
	autocmd FileType python setlocal textwidth=79
	" NOTE: see pep8
	" is not working?
	"if has('python3')
		"autocmd FileType python setlocal omnifunc=python3complete#Complete
	"endif

" cpp
	"autocmd Filetype cpp setlocal nocindent
augroup END

" nyan_vimrc_bg for background
augroup nyan_vimrc_bg
	autocmd!
	autocmd VimEnter,ColorScheme * highlight Normal ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight NonText ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight TablineSel ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight LineNr ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight CursorLineNr ctermbg=NONE
	if has('terminal')
		autocmd VimEnter,ColorScheme * highlight Terminal ctermbg=NONE
	endif
augroup END
let s:toggle_bg_state = 1
function! s:toggleBackground() abort
	if s:toggle_bg_state == 1
		augroup nyan_vimrc_bg
			autocmd!
		augroup END
		let s:toggle_bg_state = 0
		execute 'colorscheme ' . g:colors_name
	else
		augroup nyan_vimrc_bg
			autocmd!
			autocmd ColorScheme * highlight Normal ctermbg=NONE
			autocmd ColorScheme * highlight NonText ctermbg=NONE
			autocmd ColorScheme * highlight TablineSel ctermbg=NONE
			autocmd ColorScheme * highlight LineNr ctermbg=NONE
			autocmd ColorScheme * highlight CursorLineNr ctermbg=NONE
			if has('terminal')
				autocmd ColorScheme * highlight Terminal ctermbg=NONE
			endif
		augroup END
		let s:toggle_bg_state = 1
		execute 'colorscheme ' . g:colors_name
	endif
endfunction
command! ToggleBackground call s:toggleBackground()


"-----| nvim |-----"
if has('nvim')
	" NOTE: nvimのterminal mode
	tnoremap <Esc> <C-\><C-n>
endif


" vim: set textwidth=0 :

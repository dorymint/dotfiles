" vimrc

source $VIMRUNTIME/defaults.vim

"-----| encoding |-----"
set encoding=utf-8
scriptencoding utf-8

" 時間が取れたら整理する
" コメント多めに書く

" 設定の詳細は :help で調べればまず困らない
" <F1> キーで help を開く
" 日本語のヘルプは https://github.com/vim-jp/vimdoc-ja

" NORMALモードで : を押すとExコマンドを入力するモードに移る
" vimrc の設定は Vim script によって書かれる、基本はExコマンドの列挙

" set の詳細は :help :set で確認
" :help option-summary にオプションの要約が列挙されている
" :help option-list でオプションのリストが見れる
" 現在のオプションの値を確認するには :set {OptionName}? で見れる
" 例えば :set encoding?

" scriptencoding utf-8 はマルチバイト文字が現れる前に書くといい
" set encoding=utf-8 を付けるなら scriptencoding の前にする
" set はできるだけ省略せずに書く set nohl -> set nohlsearch
" 詳しくはアンチパターンを確認
" vimrc アンチパターンは https://github.com/vim-jp/reading-vimrc/wiki

" Vim script の文は行頭の非空白文字を \ にすることで直前の行と連結できる

" :echo は内部変数を除くのにべんり :echo &encoding
" 関数の結果を見るにもべんり :echo expand("%:p")
" :help echo

" expand("%:p") で fullpath が取れる
" 現在開いているファイルのフルパス :echo expand("%:p")
" ホームの展開 :echo expand("~/")

" boolean
" :help expr4
" v:true = 1
" v:false = 0

" 以下のヘルプを見ておけば迷わないと思う
" :help vimtutor
" :help quickref
" :help index
" :help script

" 見ておきたいヘルプ
" base
" :help
" :help help
" :help helplang
" :help search-commands
" :help set-option
" :help option-summary
" :help option-list
" mapping
" :help index
" :help mapping
" :help motion
" :help operator
" function
" :help function
" :help functions
" :help function-list
" :help expand
" variable
" :help variables
" :help internal-variables
" etc
" :help grep
" :help helpgrep
" :help vimgrep
" :help :filenamme
" :help quickfix
" :help runtimepath
" :help scriptnames
" :help object-motions
" :help registers
" :help special-buffers
" :help spell
" :help eval
" :help expression-syntax
" :help expression-commands
" :help :bar
" :help 8g8

"-----| plugin manage |-----"
if (has('win32') || has('win64')) &&
      \ isdirectory(expand('~/.vim')) &&
      \ (matchstr(&runtimepath, expand('~/.vim,')) ==# "")
  " linux に合わせる
  set runtimepath^=~/.vim,~/.vim/after
endif

" plugin manager
if v:true
  " plug
  if filereadable(expand('~/.vim/autoload/plug.vim'))
    source ~/dotfiles/vim/plugin-manage-plug.vim
  endif
else
  " minpac
  if filereadable(expand('~/dotfiles/vim/minpac-pkg.vim'))
    source ~/dotfiles/vim/minpac-pkg.vim
  endif
endif

"-----| set |-----"
set ttyfast
set notimeout
"set timeoutlen=1000
set ttimeout
set ttimeoutlen=100

" ファイルの先頭行と最終行のコメントで set できる
set modeline
" 上下から modeline を確認する行数を指定する
set modelines=5

set hidden
set autoread

" 貼り付けで形が崩れる場合は :paste して貼付け後に :nopaste する
set nopaste

set backspace=indent,eol,start
set completeopt=menuone,preview
set display=truncate
"set nrformats=bin,octal,hex
set helplang=ja,en

set title
set ruler
set number
set norelativenumber
set scrolloff=5
set textwidth=0
set wrap

" 折り返しのインデントを合わせる,vim8
set breakindent

" :help revins :)
set norevins

" spell
set nospell
" cjk を追加で東アジア圏の言葉をチェックから除外できるらしい
set spelllang=en,cjk

" cursor
set nocursorcolumn
set nocursorline

" foldmethod
set foldmethod=marker
"set foldmarker={{{,}}}
"set foldlevel=0
set nofoldenable
function! Giko()
  return ' (,,ﾟДﾟ)' . foldtext()
endfunction
set foldtext=Giko()

" showmatch
set showmatch
set matchtime=1
set matchpairs=(:),{:},[:],<:>

" cmdline
set showcmd
set history=1000
set cmdheight=1
set wildmenu
set wildmode=list:longest,full
set confirm

" vimから呼ぶシェルを設定, shell=zsh
"set shell=bash

" search
set incsearch
set hlsearch

" 置換処理のマッチにも影響するため注意
" ignorecase 大文字少文字を区別しない
" smartcase 検索条件に大文字が含まれると noignorecase
set ignorecase
set smartcase

" indent
set autoindent
set smartindent
set shiftwidth=2
set smarttab

" tab
set noexpandtab
set tabstop=2
set softtabstop=2

" list
set list
" 考慮中 eol:↵
set listchars=tab:>-,trail:-,nbsp:%,extends:>,precedes:<

" statusline
set laststatus=2
" %[n]?[.] の形式で指定してる、詳細は :help statusline で確認
set statusline=%f
set statusline+=%m
set statusline+=%r
set statusline+=%w
set statusline+=%y
set statusline+=%{&fileencoding}
set statusline+=[%{&fileformat}]
set statusline+=%=
set statusline+=%(buf[%n]hex[%4B]line[%4l/%4L:%4P]%)

" tabline
"set showtabline=1
" 設定は statusline と似てる :help tabline
"set tabline=""

" split
set splitbelow
set splitright

" visualbell
" set visualbell でbeep音を画面のフラッシュと置き換える
" t_vb= でフラッシュのターミナルコードを空指定してフラッシュさせない
set visualbell
set t_vb=

" backup, swap, undo
set nobackup
set writebackup
set noundofile
set noswapfile
" tmp directory
if isdirectory(expand('~/dotfiles/vim/tmp'))
  set backupdir=~/dotfiles/vim/tmp/backup
  set undodir=~/dotfiles/vim/tmp/undo
  set directory=~/dotfiles/vim/tmp/swap
  set backup
  set undofile
  set swapfile
endif

"-----| color |-----"
" colorscheme
"set background=dark
if $TERM ==# 'xterm-256color' ||
      \ $TERM ==# 'xterm-termite' ||
      \ $TERM ==# 'screen-256color' ||
      \ $TERM ==# 'rxvt-unicode-256color'
  set t_Co=256
  try
    colorscheme jellybeans
    "colorscheme hybrid
    "colorscheme iceberg
    "colorscheme molokai
  catch
  endtry
else
  try
    colorscheme elflord
  catch
  endtry
endif

syntax on

"-----| key map |-----"
" (,,ﾟДﾟ)つ:help index
" default のマップは :help index で確認できる
" user定義のマップは :imap :nmap :vmap :map :verbose map で確認できる
" なるべくデフォルトを消さないようにマップする
" 端末制御が使うキーはマップに注意する
" <C-s> は tty への入力受付をロックする? <C-q> で復帰
" <C-b> は tmux と被る、 tmux を変えずに vim でマップしないように
" <C-z> はサスペンド、 jobs でサスペンドの確認、 fg でフォアグラウンド
" <Nop> でマップを無効にできる
" コマンドのキーマップは <C-u> で数値の前置を消しておかないと範囲指定される
" mapleader が有用 :help <Leader>

" mapleader
let g:mapleader = "\<Space>"
let g:maplocalleader = '\'

" Nop:
  " netrw
  nnoremap gx <Nop>
  vnoremap gx <Nop>

  " fold eliminate
  nnoremap zE <Nop>

  " exit
  nnoremap ZZ <Nop>
  nnoremap ZQ <Nop>

  " Arrow keys
  nnoremap <Up>    <Nop>
  nnoremap <Down>  <Nop>
  nnoremap <Left>  <Nop>
  nnoremap <Right> <Nop>

" NORMAL:
  " Resize window
  nnoremap <Up>    <C-w>+
  nnoremap <Down>  <C-w>-
  nnoremap <Left>  <C-w><
  nnoremap <Right> <C-w>>

  " 行を上下に引っ張る
  " . は現在行
  nnoremap <C-j> :<C-u>. move +1<CR>
  nnoremap <C-k> :<C-u>. move -2<CR>

  " カーソル移動後、画面中央にフォーカス
  nnoremap n nzz
  nnoremap N Nzz

  " <Leader>
    " Buffer
    nnoremap <Leader>j :<C-u>bnext<CR>
    nnoremap <Leader>k :<C-u>bprev<CR>
    nnoremap <Leader>b :<C-u>ls<CR>:buffer<Space>
    nnoremap <Leader>d :<C-u>ls<CR>:bdelete<Space>

    " Tabpage
    nnoremap <Leader>N :<C-u>tabnew<CR>
    nnoremap <Leader>C :<C-u>tabclose<CR>
    nnoremap <Leader>l :<C-u>tabnext<CR>
    nnoremap <Leader>h :<C-u>tabprevious<CR>
    nnoremap <Leader>L :<C-u>+tabmove<CR>
    nnoremap <Leader>H :<C-u>-tabmove<CR>

    " Mark
    nnoremap <Leader>m :<C-u>marks<CR>

    " Register
    nnoremap <Leader>r :<C-u>registers<CR>

    " Quickfix
    nnoremap <Leader>o :<C-u>copen<CR>
    nnoremap <Leader>e :<C-u>copen<CR>
    nnoremap <Leader>w :<C-u>cwindow<CR>
    nnoremap <Leader>c :<C-u>cclose<CR>
    nnoremap <Leader>n :<C-u>cnext<CR>
    nnoremap <Leader>p :<C-u>cprevious<CR>

    " Toggle
    nnoremap <Leader>/  :<C-u>set hlsearch!<CR>
    nnoremap <Leader>tn :<C-u>set number!<CR>
    nnoremap <Leader>tc :<C-u>set cursorline! cursorcolumn!<CR>
    nnoremap <Leader>te :<C-u>setlocal expandtab!<CR>
    nnoremap <Leader>ts :<C-u>setlocal spell!<CR>
    nnoremap <Leader>tp :<C-u>setlocal paste!<CR>

    " Reset
    nnoremap <Leader>f  :<C-u>setlocal filetype=
    nnoremap <Leader>st :<C-u>setlocal textwidth=0
    nnoremap <Leader>se :<C-u>e ++enc=shift_jis

    " Search and move
    " :help n
    " :help }
    " TODO: autocmd FileType で設定したほうがよさそう?
    " c: autocmd FileType c nnoremap <buffer> <Leader>; /}<RC>
    " ruby: autocmd FileType ruby nnoremap <buffer> <Leader>; /end<CR>
    nnoremap <Leader>; /^$<CR>

    " match over 80 characters
    nnoremap <Leader>80 /\%80v.\+<CR>

" INSERT:
  " <C-[> に慣れた方がいいかも
  " ノーマルモードに
  "inoremap jj <Esc>
  "inoremap jk <Esc>
  "inoremap kj <Esc>

  " インサートモードの移動
  " <C-b> tmux
  " <C-h> バックスペース
  " <C-f> 再インデント
  "inoremap <C-f> <Right>
  "inoremap <C-b> <Left>

  " emacs
  "inoremap <C-a> <Home>
  "inoremap <C-e> <End>
  "inoremap <C-b> <Left>
  "inoremap <C-a> <Right>
  "inoremap <C-p> <Up>
  "inoremap <C-n> <Down>

  " 閉じ括弧
  " <enter> と <CR> 違いがよくわかってない
  " 入力は別扱い、挿入が <eol> 、書き込みが ff 依存?
  if v:false
    inoremap {} {}<C-g>U<Left>
    inoremap () ()<C-g>U<Left>
    inoremap [] []<C-g>U<Left>
    inoremap <> <><C-g>U<Left>
    inoremap "" ""<C-g>U<Left>
    inoremap '' ''<C-g>U<Left>
  endif
  inoremap {<Enter> {}<Left><Enter><Esc><S-o>
  inoremap {<CR>    {}<Left><CR><Esc><S-o>
  inoremap (<Enter> ()<Left><Enter><Esc><S-o>
  inoremap (<CR>    ()<Left><CR><Esc><S-o>
  inoremap [<Enter> []<Left><Enter><Esc><S-o>
  inoremap [<CR>    []<Left><CR><Esc><S-o>

  " オムニ補完
  inoremap <S-Tab> <C-x><C-o>

  " for undo
  inoremap <C-u> <C-g>u<C-u>
  inoremap <C-w> <C-g>u<C-w>

  " 全角を半角に
  " :help i_ctrl-v
  inoremap 　 <Space>
  inoremap （ (
  inoremap ） )
  inoremap ｛ {
  inoremap ｝ }
  inoremap ； ;
  inoremap ： :
  inoremap ｜ <Bar>
  inoremap ＜ <
  inoremap ＞ >
  inoremap ＊ *
  inoremap ＠ @
  inoremap ％ %
  inoremap ＃ #
  inoremap ’ '
  inoremap ＋ +
  inoremap ０ 0
  inoremap １ 1
  inoremap ２ 2
  inoremap ３ 3
  inoremap ４ 4
  inoremap ５ 5
  inoremap ６ 6
  inoremap ７ 7
  inoremap ８ 8
  inoremap ９ 9
  inoremap ？ ?
  inoremap ！ !
  "inoremap ー -
  "inoremap 〜 ~

"-----| command |-----"
command! -complete=command -nargs=1 Type verbose command <args>

function! s:scratch() abort
  new
  setlocal buftype=nofile
  setlocal bufhidden=hide
  setlocal noswapfile
endfunction
command! Scratch call s:scratch()

if executable('xclip')
  command! Paste read !xclip -o
  command! -range Cut <line1>,<line2>!xclip
  command! -range Yank execute "<line1>,<line2>!xclip" | undo
endif

if exists('*strftime')
  command! Timestamp put =strftime('%Y-%m-%d %T')
endif

" for edit the binary files
if executable('xxd')
  function! s:toggle_xxd() abort
    if &filetype ==# 'xxd'
      setlocal filetype=
      %!xxd -r
    else
      setlocal filetype=xxd
      %!xxd
    endif
  endfunction
  command! Xxd call s:toggle_xxd()
endif

"-----| filetype |-----"
" filetypeによる挙動の変化を有効に設定
" :help filetype
filetype plugin indent on

" autocmd は再読込されるたびに重複して登録される
" autocmd! でグループの autocmd を初期化して重複を防ぐ

" for filetype
augroup my_vimrc_ft
  autocmd!
  " vim
  function! s:ftvim()
    setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2
  endfunction
  autocmd FileType vim call s:ftvim()

  " sh
  function! s:ftsh()
    setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2
  endfunction
  autocmd FileType sh call s:ftsh()

  " go
  function! s:ftgo()
    setlocal noexpandtab shiftwidth=4 tabstop=4 softtabstop=2
  endfunction
  autocmd FileType go call s:ftgo()

  " rust
  function! s:ftrust()
    "setlocal expandtab shiftwidth=4 tabstop=4 softtabstop=4 textwidth=99
  endfunction
  autocmd FileType rust call s:ftrust()

  " python
  function! s:ftpython()
    setlocal textwidth=78
  endfunction
  autocmd FileType python call s:ftpython()

  " gitcommit
  function! s:ftgitcommit()
    setlocal spell
  endfunction
  autocmd FileType gitcommit call s:ftgitcommit()

  " javascript
  function! s:ftjavascript()
    setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2
  endfunction
  autocmd FileType javascript call s:ftjavascript()

  " json
  function! s:ftjson()
    setlocal expandtab shiftwidth=2 tabstop=2 softtabstop=2
  endfunction
  autocmd FileType json call s:ftjson()

  " markdown
  function! s:ftmarkdown()
    setlocal spell
  endfunction
  autocmd FileType markdown call s:ftmarkdown()

  " text
  function! s:fttext()
    nnoremap <buffer> <Leader>st :setlocal textwidth=78
  endfunction
  autocmd FileType text call s:fttext()
augroup END

" for bg NONE
augroup my_vimrc_bg
  autocmd!
  autocmd VimEnter,ColorScheme * highlight Normal ctermbg=NONE
  autocmd VimEnter,ColorScheme * highlight NonText ctermbg=NONE
  autocmd VimEnter,ColorScheme * highlight TablineSel ctermbg=NONE
  autocmd VimEnter,ColorScheme * highlight LineNr ctermbg=NONE
  autocmd VimEnter,ColorScheme * highlight CursorLineNr ctermbg=NONE
  autocmd VimEnter,ColorScheme * highlight Terminal ctermbg=NONE
augroup END
let s:is_none_bg = v:true
function! s:toggleBackground() abort
  if s:is_none_bg
    augroup my_vimrc_bg
      autocmd!
    augroup END
    let s:is_none_bg = v:false
  else
    augroup my_vimrc_bg
      autocmd!
      autocmd ColorScheme * highlight Normal ctermbg=NONE
      autocmd ColorScheme * highlight NonText ctermbg=NONE
      autocmd ColorScheme * highlight TablineSel ctermbg=NONE
      autocmd ColorScheme * highlight LineNr ctermbg=NONE
      autocmd ColorScheme * highlight CursorLineNr ctermbg=NONE
      autocmd ColorScheme * highlight Terminal ctermbg=NONE
    augroup END
    let s:is_none_bg = v:true
  endif
  execute 'colorscheme ' . g:colors_name
endfunction
command! ToggleBackground call s:toggleBackground()

" vim: textwidth=0 expandtab shiftwidth=2 tabstop=2 softtabstop=2

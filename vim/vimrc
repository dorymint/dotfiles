"
" vimrc
"
"-----| fileencoding |-----"
set encoding=utf-8
scriptencoding utf-8

" TODO: 時間が取れたら整理する
" コメント多めに書く
" fix for windows

" NOTE: 設定の詳細は:helpで調べればまず困らない
" 日本語のヘルプは https://github.com/vim-jp/vimdoc-ja
" scriptencoding utf-8 はマルチバイトが現れる前の先頭に書くといい
" また set encoding=utf-8 を付けるなら scriptencoding の前にする
" 詳しくはアンチパターンを確認
" vimrc アンチパターンは https://github.com/vim-jp/reading-vimrc/wiki
" NORMALモードで : を押すとコマンドを入力するモードに移る
" setの詳細は :help ${name} もしくは :help set で確認
" setはできるだけ省略せずに書く set nohl --> set nohlsearch
" Vim script は最初の非空白文字を \ にすることで前の行と連結できる
" vim の echo は内部変数を除くのにべんり :echo &encoding
" 関数の結果を見るにもべんり :echo expand("%:p")
" :help echo
" @% で現在のファイルパスが取れる
" :echo @%
" fullpath は :echo expand("%:p")

" NOTE: true and false
" those variable is read only
" v:true = 1
" v:false = 0
" :echo v:true != v:false
" :echo v:true == v:false

" NOTE: 以下のヘルプを見ておけば迷わないと思う
" base
" :help
" :help help
" :help helplang
" :help search-commands
" :help set-option
" :help option-summary
" mapping
" :help index
" :help motion
" :help operator
" function
" :help function
" :help functions
" :help function-list
" :help expand
" variable
" :help internal-variables
" :help v:
" :help v:true
" :help v:false
" :help g:
" :help s:
" extra
" :help grep
" :help helpgrep
" :help vimgrep
" :help {file}
" :help quickfix
" :help runtimepath
" :help scriptnames
" :help object-motions
" :help registers
" :help special-buffers

" NOTE: useful vimgrep
" バッククォートはunixだけらしい
" :vim ${pattern} `git ls-files`

"-----| plugin manage |-----"
if (has('win32') || has('win64')) && isdirectory(glob('~/.vim'))
	" NOTE: linuxに合わせる
	set runtimepath^=~/.vim,~/.vim/after
endif

" select plugin manager
if v:true
	" plug
	if filereadable(glob('~/.vim/autoload/plug.vim'))
		source ~/dotfiles/vim/plugin-manage-plug.vim
	endif
else
	" minpac
	if filereadable(glob('~/dotfiles/vim/minpac-pkg.vim'))
		source ~/dotfiles/vim/minpac-pkg.vim
	endif
endif


"-----| set |-----"
set ttyfast
set notimeout
"set timeoutlen=1000
set ttimeout
set ttimeoutlen=100
set modeline

" NOTE: modelines ファイル頭と尻尾のコメントを書くとき注意する
" {vi:|vim:|Vim:|ex:}でぶつかる
set modelines=5

set hidden
set autoread

" NOTE: 貼り付けで形が崩れる場合は :paste して貼付け後に :nopaste する
set nopaste

set backspace=indent,eol,start
set completeopt=menuone,preview
set display=truncate
set nrformats=bin,octal,hex
set helplang=ja,en
set nospell

" NOTE: cjk を追加で東アジア圏の言葉をチェックから除外できるらしい
set spelllang=en,cjk

set title
set ruler
set number
set norelativenumber
set scrolloff=5
set textwidth=0
set wrap

" NOTE: 折り返しのインデントを合わせる,vim8
set breakindent

" NOTE: :help revins :)
set norevins

" cursor
set nocursorcolumn
set nocursorline

" foldmethod
set foldmethod=marker
set foldmarker={{{,}}}
set foldlevel=0

" NOTE: デフォルトは開くように
" :help zi
set nofoldenable
function! Giko()
	return ' (,,ﾟДﾟ)' . foldtext()
endfunction
set foldtext=Giko()

" showmatch
set showmatch
set matchtime=1
set matchpairs=(:),{:},[:],<:>

" cmdline
set showcmd
set history=1000
set cmdheight=1
set wildmenu
set wildmode=list:longest,full
set confirm

" NOTE: vimから呼ぶシェルを設定, shell=zsh
"set shell=bash

" search
set incsearch
set hlsearch

" NOTE: 置換処理のマッチにも影響するため注意
" ignorecase 大文字少文字を区別しない
" smartcase 検索条件に大文字が含まれると noignorecase
set ignorecase
set smartcase

" indent
set autoindent
set smartindent
set shiftwidth=2
set smarttab

" tab
set noexpandtab
set tabstop=2
set softtabstop=2

" list
set list
" NOTE: eolは考慮中 eol:↵
set listchars=tab:>-,trail:-,nbsp:%,extends:>,precedes:<

" statusline
set laststatus=2
" NOTE: %[n]?[.] の形式で指定してる、詳細は:help statuslineで確認
set statusline=%f%m%r%w%y%{&fileencoding}[%{&fileformat}]%=%(buf[%n]hex[%4B]line[%4l/%4L:%4P]%)

" tabline
set showtabline=1
" NOTE: 設定はstatuslineと似てる :help tabline
"set tabline=

" split
set splitbelow
set splitright

" visualbell
" NOTE: set visualbell でbeep音を画面のフラッシュと置き換える
" t_vb= でフラッシュのターミナルコードを空指定してフラッシュさせない
set visualbell
set t_vb=

" backup, swap, undo
set nobackup
set writebackup
set noundofile
set noswapfile
" tmp directory
if isdirectory(glob('~/dotfiles/vim/tmp'))
	set backupdir=~/dotfiles/vim/tmp/backup
	set undodir=~/dotfiles/vim/tmp/undo
	set directory=~/dotfiles/vim/tmp/swap
	set backup
	set undofile
	set swapfile
endif


"-----| color |-----"
" colorscheme
"set background=dark
if $TERM == "xterm-256color" ||
			\ $TERM == "xterm-termite" ||
			\ $TERM == "screen-256color" ||
			\ $TERM == "rxvt-unicode-256color"
	set t_Co=256
	try
		colorscheme jellybeans
		"colorscheme hybrid
		"colorscheme iceberg
		"colorscheme molokai
	catch
	endtry
else
	try
		colorscheme elflord
	catch
	endtry
endif

" set has win
if has('win32') || has('win64')
	set t_Co=16
endif

syntax on


"-----| key map |-----"
" NOTE: (,,ﾟДﾟ)つ:help index
" defaultのマップは :help index で確認できる
" user定義のマップは :imap :nmap :vmap :map :verbose map で確認できる
" なるべくデフォルトを消さないようにマップする
" <C-s>はttyへの入力受付をロックする?<C-q>で復帰、端末制御に使うキーはマップに注意する
" <C-b>はtmuxと被る、tmuxを変えずにvimでマップしないようにしてみる
" <C-z>はサスペンド、jobsでサスペンドの確認、fgでフォアグラウンド
" <Nop>はマップを削除できる
" コマンドのキーマップは<C-u>で数値の前置を消しておかないと範囲指定される
" mapleaderが有用
" :help <Leader>

" mapleader
if v:true
	let g:mapleader = "\<Space>"
	let g:maplocalleader = "\\"
endif


" NORMAL map
	" NOTE: disable all erase?
	"nnoremap zE <Nop>

	" Resize window
	nnoremap <Up> <Nop>
	nnoremap <Down> <Nop>
	nnoremap <Left> <Nop>
	nnoremap <Right> <Nop>
	" NOTE: <Nop> で消しておくとリサイズの処理が軽くなる?
	nnoremap <Up> <C-w>+
	nnoremap <Down> <C-w>-
	nnoremap <Left> <C-w><
	nnoremap <Right> <C-w>>

	" 行を上下に引っ張る
	" NOTE: <C-k>はファイルの先頭で入れると行が消える、挙動の理由がよくわかってない
	" ddまでは動いて、kが失敗すると止まるっぽい? dd && k && P
	"nnoremap <C-j> ddp
	"nnoremap <C-k> ddkP
	" NOTE: reg を汚さない . は現在行、こちらなら行は消えない
	nnoremap <C-j> :<C-u>. move +1<CR>
	nnoremap <C-k> :<C-u>. move -2<CR>

	" Prefix: <Leader>
		" NOTE: reserved prefixes
		" Quickfix:
			" <Leader>c
			" <Leader>n
			" <Leader>p
		" Toggle:
			" <Leader>t
		" Set:
			" <Leader>set
		" Hex:
			" <Leader>xxd
			" <Leader>rxxd

		" Buffer
		nnoremap <Leader>j :<C-u>bnext<CR>
		nnoremap <Leader>k :<C-u>bprev<CR>
		nnoremap <Leader>bl :<C-u>ls<CR>:buffer<Space>
		nnoremap <Leader>bs :<C-u>ls<CR>:sbuffer<Space>
		nnoremap <Leader>bd :<C-u>ls<CR>:bdelete<Space>

		" Tabpage
		nnoremap <Leader>l :<C-u>tabnext<CR>
		nnoremap <Leader>h :<C-u>tabprevious<CR>
		nnoremap <Leader>N :<C-u>tabnew<CR>
		nnoremap <Leader>C :<C-u>tabclose<CR>
		" TODO: consider to remove
		nnoremap <Leader>ml :<C-u>+tabmove<CR>
		nnoremap <Leader>mh :<C-u>-tabmove<CR>

		" Mark
		nnoremap <Leader>mm :<C-u>marks<CR>

		" Register
		" NOTE: help: registers
		nnoremap <Leader>reg :<C-u>registers<CR>

		" Search and move
		" NOTE: :help pattern
		" TODO: autocmd FileType で設定したほうがよさそう
		" ruby なら
		" autocmd FileType ruby nnoremap <buffer> <Leader>; /end<CR>
		" とか
		nnoremap <Leader>; /}<CR>
		nnoremap <Leader>> /><CR>
		" NOTE: match over 80 characters
		nnoremap <Leader>80 /\%80v.\+<CR>

		" Quickfix: <Leader>c
		nnoremap <Leader>cn :<C-u>cnext<CR>
		nnoremap <Leader>n :<C-u>cnext<CR>
		nnoremap <Leader>cp :<C-u>cprevious<CR>
		nnoremap <Leader>p :<C-u>cprevious<CR>
		nnoremap <Leader>co :<C-u>copen<CR>
		nnoremap <Leader>cw :<C-u>cwindow<CR>
		nnoremap <Leader>cc :<C-u>cclose<CR>

		" Toggle: <Leader>t
		nnoremap <Leader>th :<C-u>set hlsearch!<CR>
		nnoremap <Leader>tl :<C-u>set list!<CR>
		nnoremap <Leader>tc :<C-u>set cursorcolumn! cursorline!<CR>
		nnoremap <Leader>tn :<C-u>set number!<CR>
		nnoremap <Leader>te :<C-u>setlocal expandtab!<CR>
		nnoremap <Leader>ts :<C-u>setlocal spell!<CR>
		nnoremap <Leader>tp :<C-u>setlocal paste!<CR>
		nnoremap <Leader>tr :<C-u>setlocal readonly!

		" Set: <Leader>set
		nnoremap <Leader>setft :<C-u>setlocal filetype=
		nnoremap <Leader>settw :<C-u>setlocal textwidth=0
		nnoremap <Leader>setenc :<C-u>e ++enc=shift_jis

		" Hex: <Leader>xxd
		" Hex: <Leader>rxxd
		if executable('xxd')
			" NOTE: 戻す時は xxd -r
			nnoremap <Leader>xxd :<C-u>setlocal filetype=xxd <Bar> %!xxd<Space>
			nnoremap <Leader>rxxd :<C-u>%!xxd -r<Space>
		endif


" INSERT mode
	" NOTE: <C-[> に慣れた方がいいかも
	" ノーマルモードに
	"inoremap jj <Esc>
	"inoremap jk <Esc>
	"inoremap kj <Esc>

	" インサートモードの移動
	" TODO: もう少し考える...無くてもいいかも
	" NOTE: <C-b> tmux とかぶる
	" <C-f> 再インデントを上書き
	" <C-h> バックスペース
	inoremap <C-f> <Right>
	inoremap <C-b> <Left>
	" NOTE: emacs
	"inoremap <C-a> <Home>
	"inoremap <C-e> <End>
	"inoremap <C-b> <Left>
	"inoremap <C-a> <Right>
	"inoremap <C-p> <Up>
	"inoremap <C-n> <Down>

	" 閉じ括弧
	" NOTE: <enter>と<CR>、違いがよくわかってない
	" 入力は別扱い、挿入が<eol>、書き込みがff依存?
	if v:false
		inoremap {} {}<C-g>U<Left>
		inoremap () ()<C-g>U<Left>
		inoremap [] []<C-g>U<Left>
		inoremap <> <><C-g>U<Left>
		inoremap "" ""<C-g>U<Left>
		inoremap '' ''<C-g>U<Left>
	endif
	inoremap {<enter> {}<Left><enter><Esc><S-o>
	inoremap {<CR> {}<Left><CR><Esc><S-o>
	inoremap (<enter> ()<Left><enter><Esc><S-o>
	inoremap (<CR> ()<Left><CR><Esc><S-o>
	inoremap [<enter> []<Left><enter><Esc><S-o>
	inoremap [<CR> []<Left><CR><Esc><S-o>

	" オムニ補完
	inoremap <S-Tab> <C-x><C-o>

	" undo
	inoremap <C-u> <C-g>u<C-u>
	inoremap <C-w> <C-g>u<C-w>

	" 全角を半角に
	" NOTE: :help i_ctrl-v
	inoremap 　 <Space>
	inoremap （ (
	inoremap ） )
	inoremap ｛ {
	inoremap ｝ }
	inoremap ； ;
	inoremap ： :
	inoremap ｜ <Bar>
	inoremap ＜ <
	inoremap ＞ >
	inoremap ＊ *
	inoremap ＠ @
	inoremap ％ %
	inoremap ＃ #
	inoremap ’ '
	inoremap ＋ +
	inoremap ０ 0
	inoremap １ 1
	inoremap ２ 2
	inoremap ３ 3
	inoremap ４ 4
	inoremap ５ 5
	inoremap ６ 6
	inoremap ７ 7
	inoremap ８ 8
	inoremap ９ 9
	inoremap ？ ?
	inoremap ！ !
	"inoremap ー -
	"inoremap 〜 ~


"-----| tool |-----"
" TODO: consider to simple
" fix for os windows
let s:errlist = []
let s:sfile = expand('<sfile>')
let s:errnum = 1
function! s:adderr(msg, ...) abort
	call add(s:errlist, {
		\ 'nr': s:errnum ,
		\ 'type': 'W' ,
		\ 'filename': s:sfile ,
		\ 'pattern': a:0 == 0 ? a:msg : a:1 ,
		\ 'text': a:msg ,
	\ })
endfunction

" TODO: consider use system("git ls-files")
function! s:gitgrep(word) abort
	execute "vimgrep " . a:word . " `git ls-files`"
	cwindow
endfunction
command! -nargs=1 GitGrep call s:gitgrep(<q-args>)
" instead
command! -nargs=1 Grep vimgrep <args> `git ls-files` | cwindow

function! s:scratch() abort
	new
	setlocal buftype=nofile
	setlocal bufhidden=hide
	setlocal noswapfile
endfunction
command! Scratch call s:scratch()

if isdirectory(glob('~/dotfiles/vim/tmp'))
	" gotcha
	if executable("gotcha")
		function! s:gotcha(...) abort
			new
			setlocal buftype=nofile
			setlocal bufhidden=hide
			setlocal noswapfile
			let l:word = a:0 == 0 ? "TODO: " : a:1
			let l:opt = "-word=\"" . l:word . "\" "
					\ . "-sync "
					\ . "-total "
					\ . "-drop-errors "
			let l:cmd = "gotcha " . l:opt
			put =system(l:cmd)
		endfunction
		command! -nargs=? Gotcha call s:gotcha(<f-args>)
	endif

	" xclip
	if executable("xclip")
		command! Paste read !xclip -o
		command! -range Cut <line1>,<line2>!xclip
	else
		call s:adderr("xclip")
	endif

	" timestamp
	if exists('*strftime')
		command! Timestamp :put =strftime('%Y/%m/%d')
	else
		call s:adderr('strftime')
	endif
endif

if !empty(s:errlist)
	call setqflist(s:errlist, 'r', { 'nr': s:errnum, 'title': 'vimrc tool errlist'})
	call setqflist(s:errlist, 'a')
	echoerr 'tools activate error: count=' . len(s:errlist) . ' check to :copen'
endif


"-----| filetype |-----"
" NOTE: filetypeによる挙動の変化を有効に設定
" :help filetype
filetype plugin indent on

function! s:ftgolang()
	setlocal noexpandtab shiftwidth=4 tabstop=4 softtabstop=4
endfunction

function! s:ftpython()
	setlocal textwidth=78
endfunction

function! s:ftgitcommit()
	setlocal spell
endfunction

" NOTE: autocmdは再読込されるたびに重複して登録される
" autocmd!でnyan_vimrcグループのautocmdを初期化して重複を防ぐ
augroup nyan_vimrc
	autocmd!
	autocmd FileType go call s:ftgolang()
	autocmd FileType python call s:ftpython()
	autocmd FileType gitcommit call s:ftgitcommit()
augroup END

" nyan_vimrc_bg for bg None
augroup nyan_vimrc_bg
	autocmd!
	autocmd VimEnter,ColorScheme * highlight Normal ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight NonText ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight TablineSel ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight LineNr ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight CursorLineNr ctermbg=NONE
	autocmd VimEnter,ColorScheme * highlight Terminal ctermbg=NONE
augroup END

" for toggle background
let s:is_none_bg = v:true
function! s:toggleBackground() abort
	if s:is_none_bg
		augroup nyan_vimrc_bg
			autocmd!
		augroup END
		let s:is_none_bg = v:false
	else
		augroup nyan_vimrc_bg
			autocmd!
			autocmd ColorScheme * highlight Normal ctermbg=NONE
			autocmd ColorScheme * highlight NonText ctermbg=NONE
			autocmd ColorScheme * highlight TablineSel ctermbg=NONE
			autocmd ColorScheme * highlight LineNr ctermbg=NONE
			autocmd ColorScheme * highlight CursorLineNr ctermbg=NONE
			autocmd ColorScheme * highlight Terminal ctermbg=NONE
		augroup END
		let s:is_none_bg = v:true
	endif
	execute 'colorscheme ' . g:colors_name
endfunction
command! ToggleBackground call s:toggleBackground()


"-----| nvim |-----"
" TODO: consider to remove
if has('nvim')
	" NOTE: nvimのterminal mode
	tnoremap <Esc> <C-\><C-n>
endif


" vim: textwidth=0
